```
Material:
Pharos University in Alexandria
Faculty of Computer Science & Artificial Intelligence
Course Title: Theory of Computation
Code: CS 307
Lecturer: Sherine Shawky

**Week 1: Introduction**

* **Theory of computation:** Deals with whether and how efficiently problems can be solved on a model of computation using an algorithm. Branches: Automata theory, Computability theory, Complexity theory.
* **Mathematical Notation:**
* Sets: Union (U), Intersection (∩), Difference, Complement (bar), Power set (), Cartesian product ().
* Functions: Mapping elements of S to T.
* Proof Techniques: Direct, Contrapositive, Contradiction, Induction.


* **Languages:**
* Alphabet (): Finite, non-empty set of symbols.
* Symbol: Indivisible object (a, 0, 1).
* String: Finite sequence of symbols.  or  = empty string. Length .
* Concatenation: . Length . .
* Star Closure (): Set of all strings over .


* **Grammars:** . V=Variables, T=Terminals, S=Start, P=Productions.

**Week 2: Finite Automata & Regular Languages**

* **DFA (Deterministic Finite Automaton):** 5-tuple .
* : Finite states. : Alphabet. : Transition function (). : Start state. : Accept states.
* Language accepted: .


* **Regular Language:** A language is regular iff it is recognized by a DFA.

**Week 3: Nondeterministic Finite Accepters (NFA)**

* **NFA:** 5-tuple .
* :  (returns a subset of states). Allows -transitions.
* Language accepted: .


* **Equivalence:** DFA and NFA are equivalent (accept same languages). Every NFA can be converted to a DFA.
* **DFA Minimization:** Combine indistinguishable states. States  are distinguishable if  such that one leads to final and the other to non-final.

**Week 4: Regular Expressions (RE)**

* **Operations:** Union (), Concatenation (), Kleene closure ().
* **Properties:**
* Associativity: .
* Distributive: .
* Idempotent: .
* Identity:  for union (),  for concatenation ().
* Commutative:  (Union only).


* **Identities:** . . .
* **Arden’s Theorem:** Solution for  is  (if  does not contain ).
* **Conversion:** RE  FA.

**Week 5: Regular Grammars**

* **Right-Linear:**  or .
* **Left-Linear:**  or .
* **Regular Grammar:** Must be either right-linear or left-linear. Generates Regular Languages.
* **Theorem:**  is regular iff there exists a regular grammar  such that .

**Week 6: Closure Properties & Pumping Lemma**

* **Closure:** Regular languages are closed under Union, Intersection, Concatenation, Kleene Closure, and Complement.
* **Pumping Lemma for RL:** Used to prove a language is **NOT** regular.
* If  is regular,  (pumping length). For string , :
1.  for every .
2. .
3. .


* Steps: Assume Regular  Choose string  Decompose  Find  that breaks condition  Contradiction.



**Week 9: Context Free Languages (CFL)**

* **CFL:** Generated by Context-Free Grammar (CFG). Includes Regular Languages. Accepted by Pushdown Automata (PDA).
* **Closure:** Closed under Union, Concatenation, Kleene Star. (Intersection/Complement not guaranteed).
* **CFG Rules:**  (where , ).
* **Derivations:**
* Leftmost: Replace leftmost variable first.
* Rightmost: Replace rightmost variable first.


* **Ambiguity:** A grammar is ambiguous if a string has  derivation tree (or  leftmost derivation).
* **Simplification:**
1. Remove Useless Productions (non-terminating or unreachable).
2. Remove -Productions ().
3. Remove Unit-Productions ().



**Week 10: Pushdown Automata (PDA)**

* **PDA:** Finite automaton + infinite Stack (LIFO).
* **Definition:** 7-tuple .
* : Stack alphabet. : Stack start symbol.
* :  finite subset of .


* **Logic:** Move depends on Input Symbol + Top of Stack.
* **Power:** Recognizes CFL (e.g., , ). Deterministic PDA (DPDA) is a subset of NPDA.

**Week 11: Turing Machine (TM)**

* **TM:** Finite control + Infinite Tape (Read/Write, Left/Right moves).
* **Definition:** 7-tuple .
* : Tape alphabet (includes  and  blank).
* : .


* **Acceptance:** Halts in a final state.
* **Operations:** Can compute functions (e.g., Adder) and recognize Recursively Enumerable languages.

**Review Questions (Compiled from Slides & Exams):**

1. **RegEx:** Language starting/ending with 'a' having any 'b's in between: .
2. **RegEx:** DFA matching state diagram: Check loops and transitions (e.g., ).
3. **DFA Analysis:** Check if DFA accepts/rejects specific strings (e.g., "11111", "000").
4. **Properties:**
*  (True).
* Every DFA is an NFA (True).
*  is finite language , not  (True).


5. **Language Design:**
* Strings ending in "11": Design DFA/NFA/RE.
* : CFG is .
* TM Adder: Convert unary  to .

### **1. Finite Automata (DFA & NFA)**

* **DFA Analysis (MCQ):** "Which of the following sentences describes the shown DFA correctly?"
* *Options:* It accepts only strings that include “10”; It rejects string “0”; It accepts string “10001”; It rejects string “000”.


* **DFA Design:** "Find a DFA that accepts all the string on {0,1}, except those containing the substring 001."
* **NFA Construction:** "Construct an NFA with ∑ = {0, 1} in which each string must contain 'double ‘1’ is followed by single ‘0’'."
* **NFA to DFA Conversion:** "Convert the nfa to an equivalent dfa."
* **State Minimization:** "Design DFA machine that accepts only strings that end with “11” over inputs {0,1}."

### **2. Regular Expressions (RE) & Grammars**

* **RE Identification (MCQ):** "Which of the following expressions describes the language that starting and ending with a and over inputs {a,b} having any combination of b's in between?"
* *Options:* ; ; ; .


* **RE Properties (True/False):** "State each of the following sentences either it is right or wrong... If r1, r2, r3 are RE, then ."
* **RE Construction:** "Write the regular expression for the language having a string which should have at least one 0 and at least one 1."
* **RE to FA Conversion:** "Design a FA from given regular expression ."
* **Regular Grammar (RG):** "Transform the following DFA to a right regular grammar."

### **3. Properties of Regular Languages**

* **Pumping Lemma:** "Using Pumping Lemma, prove that the language  is Not Regular."
* **Closure Properties:** "Show that if L1 and L2 are regular languages, their intersection L1 ∩ L2 will also be regular."

### **4. Context-Free Languages (CFL) & Grammars**

* **CFG Design:** "Construct a CFG for the language  where ."
* **CFG Design (Harder):** "Give a context-free grammar that generates the following language over : ."
* **Chomsky Normal Form (CNF):** "Convert the following CFG into CNF: , , ."
* **Ambiguity:** "Consider the grammar... The grammar is ambiguous. For instance, the string  has two different derivation trees."

### **5. Pushdown Automata (PDA)**

* **PDA Analysis (MCQ):** "Which of the following languages describes the shown PDA correctly?"
* *Options:* ; ; etc.


* **PDA Tracing:** "Given the PDA shown in the figure... Does the shown PDA accept string 'abaab'? (with steps)."
* **PDA Design:** "Construct an NPDA for accepting the language ."

### **6. Turing Machines (TM)**

* **TM Design:** "Design a TM for language that accepts strings of the form ."
* **Computational Function:** "Design a TM as an Adder." (Computing ).
* **Language Recognition:** "For , design a Turing machine that accepts ."


OUT OF SCOPE! DO NOT ASK ABOUT THEM:Mealy and Moore NFA's
GTG
Parsing tree
CNF (Chonwsky Normal form)


```